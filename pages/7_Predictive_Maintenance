import streamlit as st
import sqlite3
import pandas as pd
import os
from datetime import datetime, timedelta

st.set_page_config(page_title="Predictive Maintenance", layout="wide")
st.title("ğŸ§  Predictive Maintenance Engine")

# --- Session Info ---
user_email = st.session_state.get("user_email", "unknown@example.com")
user_role = st.session_state.get("user_role", "guest")
db_path = st.session_state.get("db_path", None)
active_table = st.session_state.get("active_table", "equipment")

st.sidebar.markdown(f"ğŸ” Role: {user_role} | ğŸ“§ Email: {user_email}")
st.sidebar.info(f"ğŸ“¦ Active Table: `{active_table}`")

if not db_path or not os.path.exists(db_path):
    st.error("No active database found. Please go to main page.")
    st.stop()

# --- Load Data ---
conn = sqlite3.connect(db_path)
equipment_df = pd.read_sql_query(f"SELECT * FROM {active_table}", conn)
maintenance_df = pd.read_sql_query("SELECT * FROM maintenance_log", conn)
conn.close()

# Normalize columns
id_col = next((c for c in equipment_df.columns if c.lower() in ["asset_id", "equipment_id"]), None)
if id_col is None:
    st.error("No equipment_id column found in active table.")
    st.stop()

equipment_df[id_col] = equipment_df[id_col].astype(str).str.strip()
maintenance_df["equipment_id"] = maintenance_df["equipment_id"].astype(str).str.strip()
maintenance_df["date"] = pd.to_datetime(maintenance_df["date"], errors="coerce")

# --- Calculate average time between maintenance ---
results = []

for eq_id in equipment_df[id_col].unique():
    history = maintenance_df.loc[maintenance_df["equipment_id"] == eq_id].sort_values("date")
    history = history.dropna(subset=["date"])
    
    if len(history) < 2:
        avg_interval = None  # not enough data to compute
    else:
        intervals = history["date"].diff().dt.days[1:]
        avg_interval = int(intervals.mean())

    last_maintenance = history["date"].max() if not history.empty else None

    if avg_interval and last_maintenance:
        predicted_next = last_maintenance + timedelta(days=avg_interval)
        days_remaining = (predicted_next - datetime.today()).days
        if days_remaining < 0:
            status = "ğŸ”´ Overdue"
        elif days_remaining <= 30:
            status = "ğŸŸ  Due Soon"
        else:
            status = "ğŸŸ¢ On Schedule"
    else:
        predicted_next = None
        status = "âšª Insufficient Data"

    results.append({
        "Equipment ID": eq_id,
        "Last Maintenance": last_maintenance.date() if pd.notna(last_maintenance) else None,
        "Avg Interval (days)": avg_interval,
        "Next Due": predicted_next.date() if predicted_next else None,
        "Days Remaining": days_remaining if avg_interval else None,
        "Predicted Status": status
    })

# --- Display Results ---
result_df = pd.DataFrame(results)

st.subheader("ğŸ“Š Predictive Schedule Table")
st.dataframe(result_df, use_container_width=True)

# Optional filter
st.sidebar.subheader("Filter By Status")
status_filter = st.sidebar.selectbox("Show:", ["All", "Overdue", "Due Soon", "On Schedule", "Insufficient Data"])

if status_filter != "All":
    emoji = {"Overdue": "ğŸ”´", "Due Soon": "ğŸŸ ", "On Schedule": "ğŸŸ¢", "Insufficient Data": "âšª"}[status_filter]
    filtered_df = result_df[result_df["Predicted Status"].str.startswith(emoji)]
    st.dataframe(filtered_df, use_container_width=True)
