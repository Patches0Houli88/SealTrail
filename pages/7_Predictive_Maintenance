import streamlit as st
import sqlite3
import pandas as pd
import yaml
import os
from datetime import datetime, timedelta

st.set_page_config(page_title="Predictive Maintenance", layout="wide")
st.title("🧠 Predictive Maintenance Engine")

# --- Session Info ---
user_email = st.session_state.get("user_email", "unknown@example.com")
user_role = st.session_state.get("user_role", "guest")
db_path = st.session_state.get("db_path", None)
active_table = st.session_state.get("active_table", "equipment")

st.sidebar.markdown(f"🔐 Role: {user_role} | 📧 Email: {user_email}")
st.sidebar.info(f"📦 Active Table: `{active_table}`")

if not db_path or not os.path.exists(db_path):
    st.error("No active database found. Please go to main page.")
    st.stop()

# --- Load Equipment + Maintenance ---
conn = sqlite3.connect(db_path)
equipment_df = pd.read_sql_query(f"SELECT * FROM {active_table}", conn)
maintenance_df = pd.read_sql_query("SELECT * FROM maintenance_log", conn)
conn.close()

# Normalize ID columns
id_col = next((c for c in equipment_df.columns if c.lower() in ["asset_id", "equipment_id"]), None)
if not id_col:
    st.error("No equipment_id column found.")
    st.stop()

equipment_df[id_col] = equipment_df[id_col].astype(str).str.strip()
maintenance_df["equipment_id"] = maintenance_df["equipment_id"].astype(str).str.strip()
maintenance_df["date"] = pd.to_datetime(maintenance_df["date"], errors="coerce")

# Load Settings YAML
settings_file = "maintenance_settings.yaml"
if os.path.exists(settings_file):
    with open(settings_file, "r") as f:
        settings = yaml.safe_load(f) or {}
else:
    settings = {}

type_col = next((c for c in equipment_df.columns if c.lower() in ["equipment_type", "type"]), None)
settings_for_table = settings.get(active_table, {})

# --- Build Prediction Table ---
results = []

for _, row in equipment_df.iterrows():
    equip_id = row[id_col]
    equip_type = str(row.get(type_col, "")).strip()

    history = maintenance_df.loc[maintenance_df["equipment_id"] == equip_id].sort_values("date")
    history = history.dropna(subset=["date"])

    # Historical learning (optional)
    if len(history) >= 2:
        intervals = history["date"].diff().dt.days[1:]
        avg_interval = int(intervals.mean())
    else:
        avg_interval = None

    # Use YAML setting if exists
    interval_setting = settings_for_table.get(equip_type, 90)

    last_maint = history["date"].max() if not history.empty else None

    # Predictive next due:
    if pd.notna(last_maint):
        predicted_next = last_maint + timedelta(days=interval_setting)
        days_remaining = (predicted_next - datetime.today()).days

        if days_remaining < 0:
            status = "🔴 Overdue"
        elif days_remaining <= 30:
            status = "🟠 Due Soon"
        else:
            status = "🟢 On Schedule"
    else:
        predicted_next = None
        days_remaining = None
        status = "⚪ Never Serviced"

    results.append({
        "Equipment ID": equip_id,
        "Equipment Type": equip_type,
        "Last Maintenance": last_maint.date() if pd.notna(last_maint) else None,
        "Interval (days)": interval_setting,
        "Avg Historical Interval": avg_interval,
        "Next Due": predicted_next.date() if predicted_next else None,
        "Days Remaining": days_remaining,
        "Predicted Status": status
    })

# --- Display Table ---
result_df = pd.DataFrame(results)
st.subheader("📊 Predictive Maintenance Table")
st.dataframe(result_df, use_container_width=True)

# --- Filters ---
st.sidebar.subheader("🔎 Filter by Status")
status_filter = st.sidebar.selectbox("Status", ["All", "Overdue", "Due Soon", "On Schedule", "Never Serviced"])

if status_filter != "All":
    emoji_map = {
        "Overdue": "🔴",
        "Due Soon": "🟠",
        "On Schedule": "🟢",
        "Never Serviced": "⚪"
    }
    filtered_df = result_df[result_df["Predicted Status"].str.startswith(emoji_map[status_filter])]
    st.dataframe(filtered_df, use_container_width=True)
